package co.stellarskys.stella.features.secrets.utils

import co.stellarskys.stella.Stella
import co.stellarskys.stella.annotations.Module
import com.google.gson.GsonBuilder
import com.google.gson.JsonObject
import net.minecraft.core.BlockPos
import java.awt.Color
import java.io.File

@Module
object RouteRegistry {
    private val ROUTES_FILE = File("config/stella/routes.json")
    private val gson = GsonBuilder().disableHtmlEscaping().create()
    private var routeFile: RouteFile = RouteFile()

    init {
        load()
    }

    fun load() {
        if (!ROUTES_FILE.exists()) {
            Stella.LOGGER.info("RouteRegistry: routes.json not found, creating new file")
            save()
            return
        }

        runCatching {
            val json = ROUTES_FILE.readText()
            val obj = gson.fromJson(json, JsonObject::class.java)

            val name = obj["#name"]?.asString ?: "Default secret routes"
            val origin = obj["#origin"]?.asString ?: "generated by Stella"
            val version = obj["Version"]?.asString ?: "1.0"

            val routes = mutableMapOf<String, RouteData>()

            for ((key, value) in obj.entrySet()) {
                if (key.startsWith("#")) continue
                if (key == "Version") continue

                // Parse steps array
                val stepsJson = value.asJsonArray
                val steps = stepsJson.map { stepElement ->
                    gson.fromJson(stepElement, StepDataSerializable::class.java)
                }

                routes[key] = RouteData(steps)
            }

            routeFile = RouteFile(name, origin, version, routes)

            Stella.LOGGER.info("RouteRegistry: Successfully loaded ${routes.size} rooms")
        }.onFailure {
            Stella.LOGGER.error("RouteRegistry: Failed to load routes.json — ${it.message}")
        }
    }

    fun save() {
        runCatching {
            val sb = StringBuilder()

            // Opening brace
            sb.append("{\n")

            // Header fields
            sb.append("    \"#name\": \"${routeFile.`#name`}\",\n")
            sb.append("    \"#origin\": \"${routeFile.`#origin`}\",\n")
            sb.append("    \"Version\": \"${routeFile.Version}\",\n\n")

            // Each room on its own line
            val entries = routeFile.routes.entries.toList()
            entries.forEachIndexed { index, (room, data) ->
                sb.append("    \"").append(room).append("\":")
                sb.append(gson.toJson(data.steps)) // compact JSON array

                // Add comma except for last entry
                if (index != entries.lastIndex) sb.append(",")
                sb.append("\n")
            }

            // Closing brace
            sb.append("}")

            ROUTES_FILE.parentFile.mkdirs()
            ROUTES_FILE.writeText(sb.toString())

            Stella.LOGGER.info("RouteRegistry: Saved routes.json")
        }.onFailure {
            Stella.LOGGER.error("RouteRegistry: Failed to save routes.json — ${it.message}")
        }
    }

    fun reload() {
        Stella.LOGGER.info("RouteRegistry: Reloading routes.json...")

        runCatching {
            load()
            Stella.LOGGER.info("RouteRegistry: Reload complete")
        }.onFailure {
            Stella.LOGGER.error("RouteRegistry: Reload failed — ${it.message}")
        }
    }

    fun saveRoute(roomName: String, steps: List<StepData>) {
        val serializable = RouteData(steps.map { it.toSerializable() })
        routeFile.routes[roomName] = serializable
        save()
    }

    fun getRoute(roomName: String): List<StepData>? =
        routeFile.routes[roomName]?.toRuntime()

    fun getAll(): Map<String, RouteData> =
        routeFile.routes

    data class RouteFile(
        val `#name`: String = "Default secret routes",
        val `#origin`: String = "generated by Stella",
        val Version: String = "1.0",
        val routes: MutableMap<String, RouteData> = mutableMapOf()
    )

    data class RouteData(
        val steps: List<StepDataSerializable>
    ) {
        fun toRuntime(): List<StepData> =
            steps.map { it.toRuntime() }
    }

    data class StepDataSerializable(
        val waypoints: List<WaypointDataSerializable>,
        val line: List<List<Int>> // [[x, y, z], ...]
    )

    data class WaypointDataSerializable(
        val pos: List<Int>,       // [x, y, z]
        val type: String,
        val name: String?,
        val color: List<Int>?     // [r, g, b]
    )

    fun BlockPos.toList() = listOf(x, y, z)
    fun Color.toList() = listOf(red, green, blue)

    fun StepData.toSerializable() = StepDataSerializable(
        waypoints = waypoints.map { it.toSerializable() },
        line = line.map { it.toList() }
    )

    fun WaypointData.toSerializable() = WaypointDataSerializable(
        pos = pos.toList(),
        type = type.name,
        name = name,
        color = color?.toList()
    )

    fun StepDataSerializable.toRuntime(): StepData {
        val runtimeWaypoints = waypoints.map { it.toRuntime() }.toMutableList()
        val runtimeLine = line.map { BlockPos(it[0], it[1], it[2]) }.toMutableList()
        return StepData(runtimeWaypoints, runtimeLine)
    }

    fun WaypointDataSerializable.toRuntime(): WaypointData {
        val pos = BlockPos(this.pos[0], this.pos[1], this.pos[2])
        val type = WaypointType.valueOf(this.type)
        val colorObj = this.color?.let { Color(it[0], it[1], it[2]) }
        return WaypointData(pos, type, name, colorObj)
    }
}
